여기에 client_secret 같은 비밀 값이 없기 때문에,
“이 파일 자체”가 보안 사고라고 보기는 어렵다.


xss 개선방안

프론트는 SSO code만 받고
Spring 백엔드가 code → token 교환 + /v2/user/me 호출 + 세션 관리
프론트는 백엔드 세션/쿠키 기반으로만 동작
이런 “백엔드 SSO 연동 후 프론트는 그냥 로그인 여부만 확인” 구조로 가야 함.
(근데 그건 아키텍처를 아예 바꾸는 얘기라, 지금 단계에선 너무 크게 돌아가는 거고)

1)쿠키 기반 + SameSite=strict + HttpOnly (서버에서 토큰 관리)
 = 서버(백엔드)가 토큰을 관리하고, 브라우저에는 HttpOnly 쿠키만 준다




2) 메모리 스토리지 사용 (sessionStorage보다 안전)
 = 토큰을 sessionStorage/localStorage 말고 **메모리(전역 상태)**에만 들고 있다

→ 새로고침하면 사라지는 특징
→ XSS에 덜 취약
→ 가장 최신 SPA 보안 트렌드

3) Content Security Policy(CSP) 강화
 = **CSP(Content Security Policy)**로 외부 스크립트, 인라인 스크립트 최대한 봉인
→ XSS 자체를 어렵게 만들어 access_token 탈취를 원천 차단


XSS = Cross-Site Scripting
한 줄 요약하면:

“공격자가 내 페이지 안에서 자기 맘대로 자바스크립트를 실행시키는 공격”










1번 상세 흐름
사용자 브라우저 → SSO 서버 로그인 페이지 이동 (지금과 동일)

SSO → https://백엔드/sso/callback?code=... 같은 백엔드 URL로 리다이렉트

지금처럼 /sso-redirect React 라우트로 보내는 게 아니라

Spring Controller가 받는 URL로 돌려보냄

Spring이 code를 받는다

@GetMapping("/sso/callback")
public void ssoCallback(@RequestParam String code, HttpServletResponse response) {
    // 1) 서버에서 AUTH_BASE /v2/oauth/token 호출 (client_id + client_secret 사용 가능)
    // 2) access_token, refresh_token 받기
    // 3) user/me 조회해서 사용자 정보 확인
    // 4) 서버 세션/DB/Redis에 userId + 토큰 저장
    // 5) HttpOnly, Secure, SameSite=strict 쿠키 생성해서 사용자 브라우저에 셋
    // 6) 최종적으로 React 진입점(/NoticeDashboard 같은 곳)으로 redirect
}


이후 브라우저에서:

React가 API 호출할 때,

fetch("/api/v1/notices");


이런 식으로 그냥 호출만 하면 됨

브라우저는 자동으로 HttpOnly 쿠키를 같이 보냄

백엔드는 쿠키 내용(세션ID나 서명된 JWT 등)을 보고 “누군지” 판단

토큰(access_token, refresh_token)은:

오직 백엔드(Spring) 내부에서만 보관

브라우저 JS에서는 절대 볼 수 없음
--------------

상세 변경 사항

① React 쪽 변경

SSORedirect.jsx에서 code → token 교환 로직 삭제

대신 /sso-redirect 같은 라우트는:

SSO 완료 후 메시지 보여주거나

사실 아예 없어도 됨 (백엔드가 바로 /NoticeDashboard로 redirect해줄 수도 있음)

API 호출 시 더 이상 Authorization: Bearer 헤더 붙이지 않음

// Before
fetch("/api/v1/notices", {
  headers: { Authorization: `Bearer ${accessToken}` }
});

// After
fetch("/api/v1/notices");  // 쿠키로 인증됨

② Spring(백엔드) 쪽 변경

/sso/callback 같은 엔드포인트 추가 (AUTH 서버 redirect_uri로 등록)

여기에서:

AUTH 서버와 통신해서 token 교환

/v2/user/me 호출

세션/DB/Redis에 사용자 정보/토큰 저장

HttpOnly 쿠키 셋팅 후 프론트 URL로 redirect

TokenAuthenticationFilter 같은 보안 필터 로직도:

지금은 헤더에서 Bearer 토큰 읽고 검증하는 형태일 텐데

앞으로는 쿠키(세션ID나 서명된 JWT)를 읽고 검증하는 로직으로 바뀔 수 있음

③ AUTH 서버 설정 변경

redirect_uri를

지금: https://프론트/sso-redirect

변경: https://백엔드/sso/callback

Public Client → Confidential Client 구조로 취급할 수도 있음
(client_secret을 서버에서만 사용하게 됨)

④ 배포/도메인 설계

가능하면 **프론트와 백엔드가 같은 도메인(or 서브도메인)**을 쓰는 게 좋아

예:

https://notice-dev.koreazinc.co.kr → 프론트 + API

그러면 SameSite=strict 쿠키로도 꽤 안전하게 갈 수 있음


--------------------------------------------


요약하면

바꾸고 싶은 “보안 쎈” 방식

Spring이 AUTH 서버에서 access_token 받음

Spring이 우리 서비스 전용 토큰/세션ID 발급

이걸 HttpOnly 쿠키에 담아서 브라우저에 내려줌

React는 아무것도 모른 채 그냥 /api/** 호출

브라우저가 자동으로 쿠키를 붙임

TokenAuthenticationFilter(또는 다른 필터)가
헤더 대신 쿠키에서 토큰/세션 값을 꺼내서 인증

그러니까 토큰이 사라지는 게 아니라, “어디에 담겨서 어떻게 전달되느냐”가 바뀌는 것이야.
